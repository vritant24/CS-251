package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;
import merkle.IMerkleTree.Node;
import merkle.IMerkleTree.NodeType;

import java.util.List;

/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @author Vritant Bhardwaj
 * @pso 17
 * @date 10/21/16
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {
        //TODO:implement
        boolean matched = false;
        /*
         * You need to use Configuration.hashFunction and this.masterHash to determine a match
         */
        String checker = "";//stores hash
        
        //is size of the list is 1, compare with masterHash
        if(pathSiblings.size() == 1) {
        	if(pathSiblings.get(0).getHash().equals(this.masterHash)) {
        		return true;
        	}
        }
        
        Node node = new Node(pathSiblings.get(0).getHash(), 0);//stores concatenated hash 
        //concatenate hashes from each node 
        for(int i = 1; i < pathSiblings.size(); i++) {
        	if(pathSiblings.get(i).getType().equals(NodeType.right)) {
        		checker = Configuration.hashFunction.concatenateHash(node, pathSiblings.get(i));
        	} else {
        		checker = Configuration.hashFunction.concatenateHash(pathSiblings.get(i), node);
        	}
        	node.setHash(checker);
        }
        
        //check if the concatenated hashes equals the current masterHash
        if(node.getHash().equals(this.masterHash)) {
        	matched = true;
        }
        return matched;
    }
}
